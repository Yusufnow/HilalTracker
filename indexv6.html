<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Hilal Tracker & Sky View</title>
    
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet-control-geocoder/dist/Control.Geocoder.css" />
    
    <style>
        body { margin: 0; padding: 0; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; overflow: hidden; background: #000; }
        
        /* Oben: Karte (60% der H√∂he) */
        #map { width: 100%; height: 60vh; z-index: 1; }
        
        /* Unten: Himmelsansicht (40% der H√∂he) */
        #sky-view { 
            width: 100%; 
            height: 40vh; 
            background: linear-gradient(to bottom, #0f172a 0%, #312e81 60%, #c084fc 100%); 
            position: relative; 
            border-top: 4px solid #fff;
            box-sizing: border-box;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
        }

        /* Schwebendes Men√º */
        .controls {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            background: rgba(255, 255, 255, 0.95);
            padding: 8px 15px;
            border-radius: 30px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.4);
            display: flex;
            gap: 10px;
            align-items: center;
        }

        input[type="date"] { padding: 8px; border-radius: 15px; border: 1px solid #ccc; outline: none; }
        
        button.calc-btn {
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: white;
            border: none;
            padding: 8px 20px;
            border-radius: 15px;
            cursor: pointer;
            font-weight: bold;
        }
        button.calc-btn:disabled { background: #ccc; cursor: wait; }

        /* Ladebalken */
        .loader {
            position: fixed; top: 0; left: 0; width: 0%; height: 4px;
            background: #00e5ff; z-index: 2000; transition: width 0.2s;
        }

        /* Text im Himmelsfenster */
        .sky-info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-size: 14px;
            text-shadow: 0 1px 3px rgba(0,0,0,0.8);
            pointer-events: none;
            background: rgba(0,0,0,0.3);
            padding: 5px;
            border-radius: 5px;
        }
        
        canvas { display: block; }
        
        /* Suchleiste Design */
        .leaflet-control-geocoder { border-radius: 20px !important; }
    </style>
</head>
<body>

    <div class="loader" id="loader"></div>

    <div class="controls">
        <input type="date" id="datePicker">
        <button class="calc-btn" onclick="calculateMap()">üöÄ Berechnen</button>
    </div>

    <div id="map"></div>

    <div id="sky-view">
        <div class="sky-info" id="skyInfoText">Klicke auf die Karte f√ºr Himmelsansicht...</div>
        <canvas id="skyCanvas"></canvas>
    </div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://unpkg.com/leaflet-control-geocoder/dist/Control.Geocoder.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/astronomy-engine@2.1.19/astronomy.browser.min.js"></script>

    <script>
        // --- 1. KARTEN SETUP ---
        const map = L.map('map', { center: [24.4, 45], zoom: 3 }); // Startet grob √ºber Saudi-Arabien/Welt
        L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
            attribution: 'Esri Satellite'
        }).addTo(map);

        // Suchfunktion
        const geocoder = L.Control.geocoder({
            defaultMarkGeocode: false,
            placeholder: "Stadt suchen..."
        }).on('markgeocode', function(e) {
            const center = e.geocode.center;
            map.setView(center, 6);
            updateSkyView(center.lat, center.lng, e.geocode.name);
            
            // Marker setzen
            L.marker(center).addTo(map).bindPopup(e.geocode.name).openPopup();
        }).addTo(map);

        // Klick auf Karte -> Himmel updaten
        map.on('click', function(e) {
            updateSkyView(e.latlng.lat, e.latlng.lng, "Gew√§hlter Ort");
        });

        // Layer Gruppen f√ºr die bunten Punkte
        const layers = {
            green: L.layerGroup().addTo(map),
            magenta: L.layerGroup().addTo(map),
            blue: L.layerGroup().addTo(map)
        };

        // Canvas f√ºr Himmel
        const canvas = document.getElementById('skyCanvas');
        const ctx = canvas.getContext('2d');
        let selectedLocation = null;

        // Datum auf Heute setzen
        document.getElementById('datePicker').valueAsDate = new Date();

        // Canvas bei Fenstergr√∂√üe anpassen
        function resizeCanvas() {
            const container = document.getElementById('sky-view');
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
            if(selectedLocation) updateSkyView(selectedLocation.lat, selectedLocation.lon, selectedLocation.name);
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();


        // --- 2. HIMMELSANSICHT (Planeten & Mond) ---

        function updateSkyView(lat, lon, name) {
            selectedLocation = { lat, lon, name };
            const dateInput = document.getElementById('datePicker').value;
            const date = new Date(dateInput);
            
            const observer = new Astronomy.Observer(lat, lon, 0);
            
            // Sonnenuntergang finden (Zeitpunkt f√ºr die Ansicht)
            date.setUTCHours(12,0,0,0); 
            const sunset = Astronomy.SearchRiseSet(Astronomy.Body.Sun, observer, 1, date, 1);
            
            if (!sunset) {
                document.getElementById('skyInfoText').innerHTML = `Kein klassischer Sonnenuntergang in<br><b>${name}</b>`;
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                return;
            }

            const time = sunset.date; 
            const localTime = time.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
            document.getElementById('skyInfoText').innerHTML = 
                `<b>${name}</b><br>Sonnenuntergang: ${localTime}<br>Blick Richtung West`;

            // Positionen aller wichtigen K√∂rper berechnen
            const bodies = [
                { name: 'Sonne', type: 'Sun', color: '#FFD700', radius: 15, glow: true },
                { name: 'Mond', type: 'Moon', color: '#FFF', radius: 10, glow: false }, // Spezieller Render
                { name: 'Venus', type: 'Venus', color: '#00FFFF', radius: 6, glow: true },
                { name: 'Jupiter', type: 'Jupiter', color: '#FFDAB9', radius: 5, glow: true },
                { name: 'Saturn', type: 'Saturn', color: '#F4A460', radius: 4, glow: true },
                { name: 'Mars', type: 'Mars', color: '#FF4500', radius: 4, glow: true },
                { name: 'Merkur', type: 'Mercury', color: '#B0C4DE', radius: 3, glow: true }
            ];

            const renderList = [];
            const centerAz = sunset.azimuth || 270; 
            const fov = 50; // Blickfeld in Grad (Zoom)
            const pxPerDeg = canvas.width / fov;

            bodies.forEach(body => {
                const astroBody = Astronomy.Body[body.type];
                const equator = Astronomy.Equator(astroBody, time, observer, true, true);
                const horizon = Astronomy.Horizon(time, observer, equator.ra, equator.dec, 'normal');
                
                renderList.push({ ...body, az: horizon.az, alt: horizon.alt });
            });

            // Zeichnen
            drawSky(renderList, centerAz, pxPerDeg);
        }

        function drawSky(bodies, centerAz, pxPerDeg) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Horizont Linie
            const horizonY = canvas.height * 0.8; 
            
            // Einfacher Farbverlauf f√ºr Himmel ist schon im CSS, hier nur Objekte
            
            // Horizontkante
            ctx.beginPath();
            ctx.moveTo(0, horizonY);
            ctx.lineTo(canvas.width, horizonY);
            ctx.strokeStyle = 'rgba(255,255,255,0.2)';
            ctx.lineWidth = 2;
            ctx.stroke();

            // K√∂rper zeichnen
            bodies.forEach(body => {
                let azDiff = body.az - centerAz;
                if (azDiff > 180) azDiff -= 360;
                if (azDiff < -180) azDiff += 360;

                const x = (canvas.width / 2) + (azDiff * pxPerDeg);
                const y = horizonY - (body.alt * pxPerDeg); 

                // Nur zeichnen, wenn im sichtbaren Bereich (+ Puffer)
                if (x > -50 && x < canvas.width + 50 && y > -100 && y < canvas.height + 50) {
                    
                    // Schein (Glow)
                    if (body.glow) {
                        ctx.beginPath();
                        ctx.arc(x, y, body.radius * 2.5, 0, Math.PI * 2);
                        ctx.fillStyle = body.color;
                        ctx.globalAlpha = 0.2;
                        ctx.fill();
                        ctx.globalAlpha = 1.0;
                    }

                    // K√∂rper
                    ctx.beginPath();
                    if (body.type === 'Moon') {
                        // Mond Kreis
                        ctx.arc(x, y, body.radius, 0, Math.PI * 2);
                        ctx.fillStyle = '#FFFFFF';
                        ctx.fill();
                        // Mondschatten (Simuliert Neumond/Sichel sehr einfach)
                        // Da wir Hilal suchen, ist der Mond fast dunkel. 
                        // Wir malen einen dunklen Kreis leicht versetzt dar√ºber.
                        ctx.fillStyle = '#222'; 
                        ctx.beginPath();
                        ctx.arc(x - 2, y - 2, body.radius * 0.9, 0, Math.PI * 2);
                        ctx.fill();
                    } else {
                        ctx.arc(x, y, body.radius, 0, Math.PI * 2);
                        ctx.fillStyle = body.color;
                        ctx.fill();
                    }

                    // Beschriftung
                    if (body.alt > -5) { // Nur beschriften wenn nicht tief unter Horizont
                        ctx.fillStyle = 'white';
                        ctx.font = '12px sans-serif';
                        ctx.textAlign = 'center';
                        ctx.fillText(body.name, x, y + body.radius + 15);
                    }
                }
            });
        }


        // --- 3. KARTEN BERECHNUNG (Odeh Kurven) ---

        function getMoonVisibility(lat, lon, dateObj) {
            // Astronomie Engine f√ºr exakte Werte nutzen
            const date = new Date(dateObj);
            date.setUTCHours(12, 0, 0, 0);
            const observer = new Astronomy.Observer(lat, lon, 0);
            const sunset = Astronomy.SearchRiseSet(Astronomy.Body.Sun, observer, 1, date, 1);
            
            if (!sunset) return null;

            const time = sunset.date;
            const sunPos = Astronomy.Equator(Astronomy.Body.Sun, time, observer, true, true);
            const moonPos = Astronomy.Equator(Astronomy.Body.Moon, time, observer, true, true);
            const moonHor = Astronomy.Horizon(time, observer, moonPos.ra, moonPos.dec, 'normal');

            const altMoon = moonHor.alt; // H√∂he
            const elongation = Astronomy.AngleBetween(sunPos.vec, moonPos.vec); // Winkelabstand
            const width = Astronomy.Illumination(Astronomy.Body.Moon, time).phase_fraction * 100;

            // Kriterien (angelehnt an Odeh/Yallop)
            if (altMoon <= 0.5) return 'invisible'; // Unter Horizont oder zu tief
            if (elongation < 6.4) return 'invisible'; // Danjon Limit

            // Odeh V-Parameter (vereinfachte Formel f√ºr Parabel-Kurve)
            // Diese Formel erzeugt die Kurve: Je weniger Elongation, desto h√∂her muss der Mond stehen
            let V = altMoon - (-0.1018 * Math.pow(elongation, 2) + 1.6787 * elongation - 5.5704);

            if (V >= 5.6) return 'green';      // Leicht sichtbar (Auge)
            if (V >= 2.0) return 'magenta';    // M√∂glich bei perfekten Bedingungen
            if (V >= -0.9) return 'blue';      // Nur Teleskop
            
            return 'invisible';
        }

        async function calculateMap() {
            const btn = document.querySelector('.calc-btn');
            const loader = document.getElementById('loader');
            const dateInput = document.getElementById('datePicker').value;
            
            if (!dateInput) return alert("Bitte Datum w√§hlen");

            btn.disabled = true;
            layers.green.clearLayers();
            layers.magenta.clearLayers();
            layers.blue.clearLayers();
            
            const step = 2; // Genauigkeit (kleiner = genauer aber langsamer)
            const date = new Date(dateInput);

            // Chunk-Verarbeitung damit Browser nicht abst√ºrzt
            const processChunk = (latStart) => {
                for (let lat = latStart; lat > -60; lat -= step) {
                    
                    // Pause machen alle 5 Grad damit UI reagiert
                    if (lat < latStart && (latStart - lat) % 5 === 0) {
                        setTimeout(() => processChunk(lat), 0);
                        return;
                    }

                    for (let lon = -180; lon < 180; lon += step) {
                        const result = getMoonVisibility(lat, lon, date);
                        
                        if (result !== 'invisible' && result !== null) {
                            let color = '#000';
                            let layer = null;

                            if (result === 'green') { color = '#00FF00'; layer = layers.green; }
                            else if (result === 'magenta') { color = '#FF00FF'; layer = layers.magenta; }
                            else if (result === 'blue') { color = '#0055FF'; layer = layers.blue; }

                            if (layer) {
                                L.circleMarker([lat, lon], {
                                    radius: 2, 
                                    fillColor: color, color: color, 
                                    weight: 0, opacity: 0.5, fillOpacity: 0.5
                                }).addTo(layer);
                            }
                        }
                    }
                    // Balken updaten
                    loader.style.width = (Math.abs(60 - lat) / 120 * 100) + "%";
                }
                
                btn.disabled = false;
                loader.style.width = "0%";
            };

            processChunk(60); // Start bei 60 Grad Nord
        }
        
        // Auto-Start beim Laden
        setTimeout(calculateMap, 1000);

    </script>
</body>
</html>
