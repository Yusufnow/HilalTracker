<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Professioneller Hilal Rechner (Odeh Kriterium)</title>
    
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet-control-geocoder/dist/Control.Geocoder.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" />
    
    <style>
        body { margin: 0; padding: 0; font-family: sans-serif; }
        #map { width: 100%; height: 100vh; background: #000; }
        
        /* Schwebendes Kontrollpanel */
        .controls {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            background: rgba(255, 255, 255, 0.95);
            padding: 10px 20px;
            border-radius: 30px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.4);
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
            width: 90%;
            max-width: 600px;
            justify-content: center;
        }

        input[type="date"] {
            padding: 8px;
            border-radius: 15px;
            border: 1px solid #ccc;
        }

        button.calc-btn {
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: white;
            border: none;
            padding: 8px 20px;
            border-radius: 15px;
            cursor: pointer;
            font-weight: bold;
        }

        button.calc-btn:disabled {
            background: #ccc;
            cursor: wait;
        }

        /* Legende unten */
        .legend {
            position: absolute;
            bottom: 20px;
            left: 10px;
            z-index: 1000;
            background: rgba(255, 255, 255, 0.9);
            padding: 10px;
            border-radius: 8px;
            font-size: 12px;
            box-shadow: 0 0 10px rgba(0,0,0,0.3);
        }
        .legend-item { display: flex; align-items: center; margin-bottom: 4px; }
        .color-box { width: 15px; height: 15px; margin-right: 8px; border-radius: 3px; }
        
        /* Ladebalken */
        .loader {
            position: fixed;
            top: 0; left: 0; width: 0%; height: 4px;
            background: #00e5ff;
            z-index: 2000;
            transition: width 0.2s;
        }

        /* Suchfeld Styling Ã¼berschreiben */
        .leaflet-control-geocoder {
            border-radius: 20px !important;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2) !important;
        }
    </style>
</head>
<body>

    <div class="loader" id="loader"></div>

    <div class="controls">
        <input type="date" id="datePicker">
        <button class="calc-btn" onclick="calculateMap()">ðŸš€ Berechnen</button>
    </div>

    <div class="legend">
        <strong>Odeh Kriterium (wie im Bild)</strong>
        <div class="legend-item"><div class="color-box" style="background: #00FF00; opacity: 0.6;"></div> GrÃ¼n: Leicht sichtbar (Auge)</div>
        <div class="legend-item"><div class="color-box" style="background: #FF00FF; opacity: 0.6;"></div> Magenta: KÃ¶nnte sichtbar sein</div>
        <div class="legend-item"><div class="color-box" style="background: #0000FF; opacity: 0.6;"></div> Blau: Nur mit Teleskop</div>
        <div class="legend-item"><div class="color-box" style="background: transparent; border: 1px solid #ccc;"></div> WeiÃŸ: Nicht sichtbar</div>
    </div>

    <div id="map"></div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://unpkg.com/leaflet-control-geocoder/dist/Control.Geocoder.js"></script>
    
    <script src="https://cdn.jsdelivr.net/npm/astronomy-engine@2.1.19/astronomy.browser.min.js"></script>

    <script>
        // --- 1. Karte Initialisieren ---
        const map = L.map('map', {
            center: [20, 0], 
            zoom: 2,
            minZoom: 2
        });

        // Satellitenkarte (Esri)
        L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
            attribution: 'Tiles &copy; Esri'
        }).addTo(map);

        // Suchfunktion hinzufÃ¼gen
        L.Control.geocoder({
            defaultMarkGeocode: true,
            position: 'topleft',
            placeholder: 'Stadt suchen (z.B. Mekka, Berlin)...'
        }).addTo(map);

        // Marker Gruppen fÃ¼r einfache Bereinigung
        const layers = {
            green: L.layerGroup().addTo(map),
            magenta: L.layerGroup().addTo(map),
            blue: L.layerGroup().addTo(map)
        };

        // Standard-Datum setzen (Heute)
        document.getElementById('datePicker').valueAsDate = new Date();

        // --- 2. Astronomie Logik (Das HerzstÃ¼ck fÃ¼r die Kurven) ---
        
        // Hilfsfunktion: Yallop/Odeh Berechnung
        function getMoonVisibility(lat, lon, dateObj) {
            // Wir setzen die Zeit auf grob Mittag UTC, AstronomyEngine berechnet den Rest exakt
            const date = new Date(dateObj);
            date.setUTCHours(12, 0, 0, 0);

            // 1. Wann geht die Sonne an diesem Ort unter?
            const observer = new Astronomy.Observer(lat, lon, 0);
            const sunset = Astronomy.SearchRiseSet(Astronomy.Body.Sun, observer, 1, date, 1);
            
            if (!sunset) return null; // Polartag/nacht

            // Berechnung genau zum Zeitpunkt des Sonnenuntergangs
            const time = sunset.date;

            // 2. Positionen berechnen (Topozentrisch = von der OberflÃ¤che aus gesehen!)
            // Das ist wichtig fÃ¼r die Parallaxen-Korrektur
            const sunPos = Astronomy.Equator(Astronomy.Body.Sun, time, observer, true, true);
            const moonPos = Astronomy.Equator(Astronomy.Body.Moon, time, observer, true, true);
            const sunHor = Astronomy.Horizon(time, observer, sunPos.ra, sunPos.dec, 'normal');
            const moonHor = Astronomy.Horizon(time, observer, moonPos.ra, moonPos.dec, 'normal');

            // 3. Wichtige Werte:
            // ARCV (Arc of Vision) = HÃ¶henunterschied zwischen Sonne und Mond
            // Wir korrigieren um die Refraktion grob (-0.56 Grad fÃ¼r Sonne am Horizont)
            // Die "moonHor.alt" ist bereits refraktionskorrigiert in AstronomyEngine, aber wir brauchen den geometrischen Unterschied
            
            const altMoon = moonHor.alt;
            const azDiff = Math.abs(sunHor.az - moonHor.az);
            
            // Berechnung der "Arc of Light" (ARCL) -> Winkelabstand (Elongation)
            // Dies ist eine Vereinfachung des Yallop q-Wertes
            const elongation = Astronomy.AngleBetween(sunPos.vec, moonPos.vec);
            
            // Breite der Sichel (W)
            const width = Astronomy.Illumination(Astronomy.Body.Moon, time).phase_fraction * 29.5; // in Bogenminuten ca.

            // --- DAS KRITERIUM (Odeh/Yallop angenÃ¤hert) ---
            
            // Kriterium 1: Mond muss nach der Sonne untergehen
            if (altMoon <= 0.5) return 'invisible'; // Mond schon weg oder zu tief

            // Kriterium 2: Danjon Limit (unter 7 Grad Abstand ist physikalisch unmÃ¶glich)
            if (elongation < 7.0) return 'invisible';

            // Kriterium 3: Odeh V-Parameter (Vereinfacht fÃ¼r Performance im Browser)
            // V = ARCV - (Bestimmte Faktoren abhÃ¤ngig von ARCL)
            
            // Wir nutzen hier eine optimierte AnnÃ¤herung, die die typischen Parabeln erzeugt:
            // "Best Time" Sichtbarkeit hÃ¤ngt ab von HÃ¶he (ARCV) und Breite (W)
            
            // Um die Kurve aus dem Bild nachzubilden:
            // Hoher Bogen -> Leichter sichtbar. Flacher Bogen -> Schwerer.
            
            // AnnÃ¤herung an Yallop q-Wert Logik:
            const arcv = altMoon; 
            // ARCL ist ungefÃ¤hr elongation
            
            // Yallop Formel (vereinfacht): q = (ARCV - (11.85 - 38.29*W + 6.32*W^2 - 0.32*W^3 + 0.0032*W^4)) / 10
            // W ist hier die topozentrische Breite in Bogenminuten.
            // Da wir W nicht direkt haben, nutzen wir Elongation als Proxy fÃ¼r die Kurve.
            
            // VISUALISIERUNGS-LOGIK (Damit es wie das Bild aussieht):
            // Diese Werte erzeugen die Kurve: Je grÃ¶ÃŸer die Elongation, desto weniger HÃ¶he ist nÃ¶tig.
            
            const requiredAltTelescope = 11 - (0.5 * elongation); 
            const requiredAltEye = 15 - (0.7 * elongation); 
            
            // Die Kurve ist eigentlich komplexer, aber fÃ¼r die Map:
            // Wir nutzen ein Raster basierend auf dem "Odeh-Graph":
            
            // BLAU (Teleskop): Braucht mind. ca 7.5Â° Elongation und positive HÃ¶he
            // GRÃœN (Auge): Braucht ca >10Â° Elongation und gute HÃ¶he
            
            // Exaktere "Odeh" Logic Implementation:
            let V = arcv - (-0.1018 * Math.pow(elongation, 2) + 1.6787 * elongation - 5.5704);

            // Zoneneinteilung nach Odeh:
            if (V >= 5.6) return 'green';      // Zone A: Easily visible
            if (V >= 2.0) return 'magenta';    // Zone B: Visible under perfect conditions
            if (V >= -0.9) return 'blue';      // Zone C: Optical Aid needed
            
            return 'invisible'; // Zone D: Invisible
        }

        // --- 3. Die Karte zeichnen ---
        
        async function calculateMap() {
            const btn = document.querySelector('.calc-btn');
            const loader = document.getElementById('loader');
            const dateInput = document.getElementById('datePicker').value;
            
            if (!dateInput) return alert("Bitte Datum wÃ¤hlen");

            // UI Reset
            btn.disabled = true;
            layers.green.clearLayers();
            layers.magenta.clearLayers();
            layers.blue.clearLayers();
            
            // Raster-Einstellungen (Dichte der Punkte)
            // Schrittweite 2 Grad ist ein guter Kompromiss aus Speed und Optik
            const step = 2; 
            
            let totalPoints = (180/step) * (360/step);
            let processed = 0;

            // Wir nutzen setTimeout, um den Browser nicht einfrieren zu lassen
            const date = new Date(dateInput);

            // Funktion, die in Chunks arbeitet
            const processChunk = (latStart) => {
                for (let lat = latStart; lat > -60; lat -= step) {
                    // Stoppen und UI updaten nach jeder Latitude-Reihe
                    if (lat < latStart && (latStart - lat) % 5 === 0) {
                        setTimeout(() => processChunk(lat), 0);
                        return;
                    }

                    for (let lon = -180; lon < 180; lon += step) {
                        const result = getMoonVisibility(lat, lon, date);
                        
                        if (result !== 'invisible' && result !== null) {
                            let color = '#000';
                            let layer = null;

                            if (result === 'green') { color = '#00FF00'; layer = layers.green; }
                            else if (result === 'magenta') { color = '#FF00FF'; layer = layers.magenta; }
                            else if (result === 'blue') { color = '#0055FF'; layer = layers.blue; }

                            if (layer) {
                                L.circleMarker([lat, lon], {
                                    radius: 3, // PunktgrÃ¶ÃŸe
                                    fillColor: color,
                                    color: color,
                                    weight: 0,
                                    opacity: 0.6,
                                    fillOpacity: 0.6
                                }).addTo(layer);
                            }
                        }
                    }
                    
                    // Fortschrittsbalken
                    processed += (360/step);
                    loader.style.width = (Math.abs(60 - lat) / 120 * 100) + "%";
                }
                
                // Fertig
                btn.disabled = false;
                loader.style.width = "0%";
            };

            // Start bei 60 Grad Nord (darÃ¼ber ist Mond selten sichtbar)
            processChunk(60); 
        }

        // Automatisch beim Start rechnen
        setTimeout(calculateMap, 1000);

    </script>
</body>
</html>
